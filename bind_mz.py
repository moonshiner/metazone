#!/usr/bin/env python3

import argparse
import dns.inet
import dns.zone
import datetime
import sys
from mzlib import gather_a, read_property, config_eval, config_lookup
from mzlib import break_apl_singleset, fixup_acl, gen_acl_hash, emit_masters
from mzlib import emit_acl, break_apl_netset, config_string, cz_hash32
from mzlib import gen_masters_name, gen_acl_name, emit_zone, emit_zone_local

#
#
# bind_mz: Generate appropriate BIND 9.16+ configuration based on metazone
#
# LM: 2021-08-03 14:26:58-07:00
# Shawn Instenes <sinstenes@gmail.com>
#
#

parser = argparse.ArgumentParser(description='Generate BIND conf from metazone')
parser.add_argument('--file', default='metazone.zone',
                    help='metazone text file to use')
parser.add_argument('--zone', default='metazone.local',
                    help='metazone name to use')
parser.add_argument('--host', default='',
                    help='FQDN of this name server')
parser.add_argument('--source', default='127.0.0.1',
                    help='IP of authoritative metazone server')
parser.add_argument('--bannermail', default='hostmaster',
                    help='Email of authoritative person/team for metazone')
parser.add_argument('--axfr', default=False, action='store_true',
                    help='IP of authoritative metazone server')
parser.add_argument('--preferv4', default=True, action='store_false',
                    help='DNS lookups prefer V4 answers')
parser.add_argument('--debug', default=False, action='store_true',
                    help='set debugging modes, spoof DNS lookups')
args = parser.parse_args()

ZONE = args.zone
DEBUG = args.debug
PREFERV4 = args.preferv4
AXFR = args.axfr

if dns.inet.is_address(args.host):
    MYNAME = args.host
else:
    hlookup = gather_a(args.host, PREFERV4, DEBUG)
    try:
        (MYNAME, more) = hlookup.split(' ', 1)  # we want the first one, if multiple
    except Exception:
        MYNAME = hlookup

if AXFR is True:
    try:
        zone = dns.zone.from_xfr(dns.query.xfr(args.source, ZONE))
    except Exception:
        sys.stderr.write(str.format("Error transferring zone from {0}\n", args.master))
        sys.exit(1)
else:
    try:
        with open(args.file, "r") as f:
            zone = dns.zone.from_file(f)
    except Exception:
        sys.stderr.write(str.format("Error reading zone from {0}\n", args.file))
        sys.exit(1)

# metazone now is a dns.zone.Zone

default_cfg = dict()
nsg_cfg = dict()
zone_cfg = dict()
null_cfg = dict()

#
#
# BIND config generation involves a base template named.conf which
#   includes three files:
#     metainc.conf  - included at top level
#     metaopts.conf - included within options stanza
#     metazone.conf - all the zone stanzas except the metazone stanza,
#       which is assumed to be in the named.conf template
#
#
try:
    mz_inc = open("metainc.conf", "w")
    mz_opts = open("metaopts.conf", "w")
    mz_zone = open("metazone.conf", "w")
except Exception:
    sys.stderr.write(str.format("Unable to open output files for writing\n"))
    sys.exit(1)

now = datetime.datetime.now()
timestr = now.strftime("%x %X")

banner = str.format("# auto-generated by metazone, DO NOT EDIT.  <{0}>\n", args.bannermail)
banner += str.format("# generated for {0} on {1}\n", MYNAME, timestr)

mz_inc.write(banner)
mz_opts.write(banner)
mz_zone.write(banner)

acllists = {}
masterlists = {}

for attr in read_property(zone, "attribute"):
    default_cfg[attr] = True

for attr in default_cfg.keys():
    default_cfg[attr] = config_string(zone, attr)

my_namespace = None
try:
    for ns in read_property(zone, MYNAME):
        my_namespace = ns
except Exception:
    my_namespace = str(zone.origin)

if my_namespace is None:
    my_namespace = str(zone.origin)

# Attempt to populate NSG defaults; it's ok if they don't exist
for itm in default_cfg.keys():
    try:
        nsg_cfg[itm] = config_string(zone, itm + "." + my_namespace)
    except Exception:
        pass

#
# Human-readable defaults for some masters lists.  These and the ACLs below
# are sometimes referenced by the named.conf template; we make sure they
# are defined by the names that are expected and not something dynamically
# generated.
#
aclmap = {'local-upstream': "masters", 'local-downstream': "also-notify-list"}
for aclname in aclmap.keys():
    acl = config_lookup(aclmap[aclname], null_cfg, nsg_cfg, default_cfg)
    if acl is None or acl.lower() == "none":
        acl = "none"
    else:
        acl = break_apl_singleset(acl)
        acl = fixup_acl(acl)
    h = gen_acl_hash(acl)
    masterlists[h] = aclname
    emit_masters(mz_inc, aclname, acl)

#
# Human-readable defaults for some acl lists.
#
aclmap = {'clients': "allow-query", 'recursive-clients': "allow-recursion",
          'transfer-hosts': "allow-transfer",
          'local-downstream-acl': "also-notify-list"}
for aclname in aclmap.keys():
    acl = config_lookup(aclmap[aclname], null_cfg, nsg_cfg, default_cfg)
    if acl is None or acl.lower() == "none":
        acl = "none"
    else:
        acl = break_apl_netset(acl)
        acl = fixup_acl(acl)
    h = gen_acl_hash(acl)
    acllists[h] = aclname
    emit_acl(mz_inc, aclname, acl)

#
# Is this host something that has a global default forward?  This is only set
# here, as there is no per-zone override.
#
will_default_forward = config_lookup('default-foward', null_cfg, nsg_cfg, default_cfg)
if will_default_forward.lower() == "false":
    default_forward_list = ''
else:
    default_forward_list = config_lookup('default-foward-list', null_cfg, nsg_cfg, default_cfg)
    if default_forward_list != '':
        default_forward_list = break_apl_singleset(default_forward_list)

if default_forward_list != '':
    mz_opts.write(str.format("\nforwarders {{ {0}; }}; forward-only;\n", default_forward_list))

#
# Looking for BIND-specific options/includes in the metazone, if any.  These will not
# generally be honored by other back ends.
#
xtraopts = config_eval('x-bind-opt', null_cfg, nsg_cfg, default_cfg, my_namespace)
if xtraopts != '':
    mz_opts.write(str.format("\n{0}\n", xtraopts))

xtrainc = config_eval('x-bind-inc', null_cfg, nsg_cfg, default_cfg, my_namespace)
if xtrainc != '':
    mz_inc.write(str.format("\n{0}\n", xtrainc))

#
# Now emit the zone lists.  There may be multiple of these, as each host will pull in
# all the zone lists configured for it.  This allows zone lists to be defined by function
# (qa, dev, production, internal) and referenced by different name server groups
# separately.
#
# TODO: revisit this logic

for zonelist in (config_lookup('zone-list', null_cfg, nsg_cfg, default_cfg)).split(" "):
    my_zone_ns = None
    try:
        my_zone = zonelist + "." + my_namespace
        for ns in read_property(zone, my_zone):
            my_zone_ns = ns
    except Exception:
        my_zone_ns = zonelist
        for ns in read_property(zone, my_zone_ns):
            my_zone_ns = ns
    if my_zone_ns is None:
        my_zone_ns = zonelist + "." + str(zone.origin)

    zone_count = config_string(zone, "zonecount." + my_zone_ns)
    digits = config_string(zone, "digits." + my_zone_ns)

    for zc in range(1, int(zone_count) + 1):
        lbl = str.format("{0:#0" + digits + "d}", zc)
        zone_name = config_string(zone, lbl + ".zonelist." + my_zone_ns)

        zone_cfg = dict()
        for key in default_cfg.keys():
            try:
                zone_cfg[key] = config_string(zone, key + "." + cz_hash32(zone_name) + "." + my_zone_ns)
                zone_cfg[key] = str(config_eval(key, zone_cfg, nsg_cfg, default_cfg, my_namespace))  # eval/fetch
            except Exception:
                pass

        mstr = config_lookup('masters', zone_cfg, nsg_cfg, default_cfg)
        if mstr is not None:
            mstr = fixup_acl(break_apl_singleset(mstr))
        else:
            mstr = args.source  # source of last resort, mentioned on command line

        mstr_list_name = gen_masters_name('masters', mstr, mz_inc, masterlists)
        mstr_line = '"' + mstr_list_name + '"'

        # Handle notify
        will_notify = config_lookup('notify', zone_cfg, nsg_cfg, default_cfg)
        if will_notify == '' or will_notify.lower() == "false":
            also_notify = ''
        else:
            also_notify = config_lookup("also-notify-list", zone_cfg, nsg_cfg, default_cfg)
            if also_notify != '':
                also_notify = break_apl_singleset(also_notify)
        if also_notify != '':
            notify_list_name = gen_masters_name('notify', also_notify, mz_inc, acllists)
            also_notify = '"' + notify_list_name + '"'

        # Handle forward.  Notice there is support for eval conditional
        will_forward = str(config_eval('forward', zone_cfg, nsg_cfg, default_cfg, my_namespace))
        if will_forward == '' or will_forward.lower() == "false":
            forward_list = ''
        else:
            local_forward_list = str(config_eval("local-forward-list", zone_cfg, nsg_cfg, default_cfg, my_namespace))
            if local_forward_list == '' or local_forward_list.lower() == "none":
                forward_list = config_eval("forward-list", zone_cfg, nsg_cfg, default_cfg, my_namespace)
                if forward_list != '':
                    forward_list = break_apl_singleset(forward_list)
            else:
                forward_list = break_apl_singleset(local_forward_list)

        # Handle query.
        allow_query = str(config_eval("allow-query", zone_cfg, nsg_cfg, default_cfg, my_namespace))
        if allow_query == '' or allow_query.lower() == "none":
            allow_query = "none"
        else:
            allow_query = break_apl_netset(allow_query)
            allow_query = fixup_acl(allow_query)
        if allow_query != '' and allow_query != "none" and allow_query != "any":
            acl_name = gen_acl_name('query', allow_query, mz_inc, acllists)
            allow_query = '"' + acl_name + '"'

        # Handle transfer.
        allow_transfer = config_eval("allow-transfer", zone_cfg, nsg_cfg, default_cfg, my_namespace)
        if allow_transfer == '' or allow_transfer.lower() == "none":
            allow_transfer = "none"
        else:
            allow_transfer = break_apl_netset(allow_transfer)
            allow_transfer = fixup_acl(allow_transfer)
        if allow_transfer != '' and allow_transfer != "none" and allow_transfer != "any":
            acl_name = gen_acl_name('transfer', allow_transfer, mz_inc, acllists)
            allow_transfer = '"' + acl_name + '"'

        # and now, the zone goes.
        zonecontent = config_eval("content", zone_cfg, nsg_cfg, null_cfg, my_namespace)  # ignore defaults for zone content
        if zonecontent != '':
            emit_zone_local(mz_zone, zone_name, zonecontent, allow_query, allow_transfer)
        else:
            emit_zone(mz_zone, zone_name, mstr_line, forward_list, also_notify, allow_query, allow_transfer)

# END OF LINE
